#双亲委派模式应该叫父委派模式比较合适:java平台通过委派模型去加载类。每个类加载器都有一个父加载器。当需要加载类时，会优先委派当前所在的类的加载器的父加载器去加载这个类。如果父加载器无法加载到这个类时，再尝试在当前所在的类的加载器中加载这个类。
#类的加载过程包括loading => linking(verification->prepare->resolve) =>initialization
#加载 => 链接(验证->准备->解析) => 初始化
#loading(加载):通过一个类的全限定名获取定义此类的二级制流,将这个二级制流所代表的静态存储结构转化为方法区的运行时数据结构,在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口
#linking(链接):
##verify(验证):验证Class文件的字节流中包含的信息是否符合当前虚拟机的要求,保证被加载类的正确性,不会危害虚拟机自身自身安全,主要包括四种验证:文件格式验证,元数据验证,字节码验证,符号引用验证
##prepare(准备):为类变量分配内存并且设置零值,1.这里不包含用final修饰的static,因为final在编译的时候就会分配了,准备阶段会显示初始化2.这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象一起分配到java堆中
##resolve(解析):将常量池内的符号引用转换为直接引用(事实上,解析操作往往会伴随着JVM在执行完初始化之后再执行)
###:符号引用就是一组符号来描述所引用的目标,符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中,直接引用就是直接指向目标的指针,相对偏移量或一个间接定位到目标的句柄
#initialization(解析):初始化阶段主要执行clinit(classinit的简写)方法,该方法仅能由Java编译器生成并由JVM调用,它是由类静态成员的赋值语句以及static语句块合并产生的
#加载的类信息存放在一块成为方法区的内存空间,除了类信息外,方法区中还会存放运行时常量池信息,可能还包括字符串字面量和数字常量(这部分常量信息是class文件中常量池部分的内存映射)
#class file加载到jvm中,被称为DNA元数据模板,放在方法区
#class文件->jvm->元数据模板,需要类装载器充当一个快递员的角色
#链接中的准备阶段为静态变量赋0值
#链接中的解析阶段会将常量池中的符号引用变为直接引用(符号引用就是用一组符号来描述所引用的目标,符号引用的字面量形式明确定义在java虚拟机规范定义的class文件格式中,直接引用就是直接指向应用的指针,相对偏移量或者一个间接定位到目标的句柄)
#初始化阶段主要执行clinit(classinit的简写)方法,该方法仅能由Java编译器生成并由JVM调用,它是由类静态成员的赋值语句以及static语句块合并产生的
#java对类的使用方式分为主动使用(主动加载)和被动使用(被动加载):
#主动使用(主动加载)包括:
#1.创建类的实例
#2.访问某个类或接口的静态变量,或者对该静态变量赋值
#3.调用类的静态方法
#4.反射,比如class.forName("com.example.Test")
#5.初始化一个类的子类
#6.java虚拟机启动时被标为启动类的类

































































